% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/piles_workflow.R
\name{piles_workflow}
\alias{piles_workflow}
\title{Workflow for slash pile detection, quantification, and spectral validation}
\usage{
piles_workflow(
  chm_rast,
  seg_method = "dbscan",
  min_ht_m,
  max_ht_m,
  min_area_m2,
  max_area_m2,
  min_convexity_ratio,
  min_circularity_ratio,
  smooth_segs = T,
  rgb_rast,
  red_band_idx,
  green_band_idx,
  blue_band_idx,
  spectral_weight = 4,
  filter_return = T,
  outfile = NA
)
}
\arguments{
\item{chm_rast}{A SpatRaster object representing the Canopy Height Model.}

\item{seg_method}{Character string. The segmentation algorithm to use:
either "watershed" or "dbscan".}

\item{min_ht_m}{Numeric. The minimum expected pile height.}

\item{max_ht_m}{Numeric. The upper limit of the vertical search space and expected pile height.}

\item{min_area_m2}{Numeric. The minimum pile footprint area required for a
segment to be retained as a candidate.}

\item{max_area_m2}{Numeric. The maximum pile footprint area expected.}

\item{min_convexity_ratio}{Numeric (0 to 1). Also known as the "solidity"
ratio. Calculated as (Area of Polygon / Area of Convex Hull). This metric
identifies segments with deep indents, holes, or branching. A perfectly
convex shape like a circle or square has a ratio of 1.0. Values closer to
0 indicate high irregularity or concavity. Note that convexity is not
sensitive to elongation.}

\item{min_circularity_ratio}{Numeric (0 to 1). Also known as the "Reock
Compactness Score." Calculated as (Area of Polygon / Area of Minimum
Bounding Circle). This measures how closely a shape is spread around its
central point. A perfect circle has a ratio of 1.0. For reference, a
perfect square is approximately 0.637 and an equilateral triangle is
approximately 0.414.}

\item{smooth_segs}{Logical. Should convex hull smoothing be applied to the
raster-detected segment boundaries to reduce pixelated edges?
Any resulting smoothed segments that overlap are removed based since
slash piles are generally distinct objects on the landscape.}

\item{rgb_rast}{A multi-band SpatRaster containing RGB imagery.}

\item{red_band_idx}{Integer. Index of the red band.}

\item{green_band_idx}{Integer. Index of the green band.}

\item{blue_band_idx}{Integer. Index of the blue band.}

\item{spectral_weight}{Integer (0 to 6). The consensus threshold
requiring a specific number of index thresholds to be met for a candidate
pile to be retained.}

\item{filter_return}{Logical. If TRUE (default), the function returns
only polygons where the "inrange_th_votes" is greater than or equal to
the \code{spectral_weight}. If FALSE, the function returns the entire input
dataset with columns for each calculated spectral index and the
"inrange_th_votes" column for post-processing and analysis.}

\item{outfile}{Character string or NA. If NA (default), the function
returns the segmented piles as an \code{sf} object. If a valid file path is
provided (e.g., "./output/detected_piles.gpkg"), the result is written
to a GeoPackage file and the function returns the character string of the
file path.}
}
\value{
If \code{outfile} is NA, returns an sf object (filtered or unfiltered
based on \code{filter_return}). If \code{outfile} is a character string, returns
the character string of the saved file path.
}
\description{
A master wrapper function that executes the full slash pile detection
and quantification framework. It identifies structural candidates using \code{\link[=piles_detect]{piles_detect()}} and
subsequently applies the spectral threshold voting system via
\code{\link[=piles_spectral_filter]{piles_spectral_filter()}} to generate final pile predictions.
}
\examples{
\dontrun{
 # load chm
 chm_fnm <- system.file(package = "cloud2trees", "extdata", "piles_chm.tif")
 my_chm <- terra::rast(chm_fnm)
 my_chm
 # load rgb
 rgb_fnm <- system.file(package = "cloud2trees", "extdata", "piles_rgb.tif")
 my_rgb <- terra::rast(rgb_fnm)
 my_rgb
 # where to write output?
 my_fnm <- tempfile()
 # piles_workflow()
 piles_workflow_ans <- piles_workflow(
   chm_rast = my_chm
   , seg_method = "dbscan"
   , min_ht_m = 1
   , max_ht_m = 6.6
   , min_area_m2 = pi*(1.5/2)^2
   , max_area_m2 = pi*(8/2)^2
   , min_convexity_ratio = 0.11
   , min_circularity_ratio = 0.22
   , smooth_segs = T
   , outfile = my_fnm
   , rgb_rast = my_rgb
   , red_band_idx = 1
   , green_band_idx = 2
   , blue_band_idx = 3
   , spectral_weight = 5
   , filter_return = F # don't filter the return so we can see what did not pass
 )
 # what does it have?
 names(piles_workflow_ans)
 # pile polygons
 piles_workflow_ans$segs_sf \%>\% dplyr::glimpse()
 # segmentation method parameters used
 piles_workflow_ans$seg_mthd_params
 # chm + structural piles since we didn't filter return
 terra::plot(my_chm, axes = F)
 piles_workflow_ans$segs_sf \%>\%
   terra::vect() \%>\%
   terra::plot(border = "magenta", lwd = 2, col = NA, add = T)
 # spectral threshold voting
 piles_workflow_ans$segs_sf \%>\%
   sf::st_drop_geometry() \%>\%
   dplyr::count(inrange_th_votes)
 # which would be removed if we set:
 # spectral_weight = 5 ?
 terra::plotRGB(
   my_rgb
   , main = "candidate piles kept (magenta) or removed (red)"
   , mar = c(0.2,0.2,2,0.2)
 )
 piles_workflow_ans$segs_sf \%>\%
   dplyr::filter(inrange_th_votes>=5) \%>\%
   terra::vect() \%>\%
   terra::plot(border = "magenta", lwd = 2, col = NA, add = T)
 piles_workflow_ans$segs_sf \%>\%
   dplyr::filter(inrange_th_votes<5) \%>\%
   terra::vect() \%>\%
   terra::plot(border = "red", lwd = 2, col = NA, add = T)
}
}
\keyword{internal}
