#' @title Spectral filtering of candidate slash piles
#' Spectral refinement of candidate slash piles
#'
#' @description Evaluates candidate segments generated by [piles_detect()]
#' against an RGB raster. It uses a voting system based on six spectral indices
#' to separate woody slash material from background vegetation or ground. This
#' function can either return a filtered dataset or the full input dataset
#' with appended spectral metrics for diagnostic purposes.
#'
#' @param sf_data An sf object of candidate polygons to be filtered.
#' @param rgb_rast A multi-band SpatRaster containing RGB imagery.
#' @param red_band_idx Integer. Index of the red band.
#' @param green_band_idx Integer. Index of the green band.
#' @param blue_band_idx Integer. Index of the blue band.
#' @param spectral_weight Integer (0 to 6). The consensus threshold
#' requiring a specific number of index thresholds to be met for a candidate
#' pile to be retained.
#' @param filter_return Logical. If TRUE (default), the function returns
#' only polygons where the "inrange_th_votes" is greater than or equal to
#' the `spectral_weight`. If FALSE, the function returns the entire input
#' dataset with columns for each calculated spectral index and the
#' "inrange_th_votes" column for post-processing and analysis.
#'
#' @return An sf object. Depending on `filter_return`, this will either be
#' a subset of the input data or the full input data with appended
#' spectral voting columns.
#'
#' @export
#'
piles_spectral_filter <- function(
  sf_data
  , rgb_rast
  # define the band index
  , red_band_idx
  , green_band_idx
  , blue_band_idx
  # spectral weighting
  , spectral_weight = 4
  # return unfiltered or filtered
  , filter_return = T
) {
  if(!inherits(filter_return,"logical")){
    stop("Input `filter_return` should be logical: T to filter return based on the `spectral_weight` or F to return the full `sf_data`")
  }

  # ### could make these parameters
  # th_grvi <- c(-Inf,0)
  # th_rgri <- c((0.7+0.001),Inf) # increase each by 0.001 since we'll be checking lower<=x<=upper
  # th_vdvi <- c(-Inf,(0.03+0.001)) # increase each by 0.001 since we'll be checking lower<=x<=upper
  # th_exgr <- c(-Inf,0)
  # th_a <- c(-5+0.001,Inf)
  # th_hue <- list(c(0,50-0.001), c(150+0.001,Inf))

  # checks
  if(!inherits(rgb_rast, "SpatRaster")){
    stop("Input `rast` must be a SpatRaster object.")
  }
  if(!inherits(sf_data, "sf")){
    stop("Input `sf_data` must be an sf data frame.")
  }
  if(!all(sf::st_geometry_type(sf_data) %in% c("POLYGON", "MULTIPOLYGON"))) {
    stop("Input `sf_data` must contain polygon geometries.")
  }
  spectral_weight <- as.numeric(spectral_weight)
  if(
    filter_return &&
    (
      is.na(spectral_weight) ||
      is.null(spectral_weight) ||
      is.nan(spectral_weight) ||
      !(spectral_weight %in% c(0:6))
    )
  ){
    stop("Input `spectral_weight` must be a number between 0 (no filtering based on spectral) and 6 (highest weighting of spectral data)")
  }
  # if you don't want to do it, then why do it?
  if(
    filter_return &&
    dplyr::coalesce(spectral_weight,0)==0
  ){
    return(sf_data)
  }
  ##################################################
  # calculate_all_rgb_indices
  ##################################################
  all_rgb_indices_rast <- calculate_all_rgb_indices(
    raster_obj = rgb_rast
    , red_band_idx = red_band_idx
    , green_band_idx = green_band_idx
    , blue_band_idx = blue_band_idx
  )
  ##################################################
  # limit to the indices we have thresholds for
  ##################################################
  some_rgb_indices_rast <-
    all_rgb_indices_rast %>%
    terra::subset(
      c(
        "grvi"
        , "rgri"
        , "vdvi"
        , "exgr"
        , "Lab_a"
        , "hsv_hue"
      )
    )
  # !!!!!!!!!!!!! convert hsv_hue to 0-360 range !!!!!!!!!!!!!
  some_rgb_indices_rast$hsv_hue <- some_rgb_indices_rast$hsv_hue*360
  ##################################################
  # extract_rast_values
  ##################################################
  rgb_indices_df <- extract_rast_values(
    sf_data = sf_data %>% dplyr::ungroup()
    , rast = some_rgb_indices_rast
    , fun_agg = median
  )
  ##################################################
  # rgb_indices_threshold_voting
  ##################################################
  rgb_indices_df <- rgb_indices_threshold_voting(
    rgb_indices_df=rgb_indices_df
    # , th_grvi = th_grvi
    # , th_rgri = th_rgri
    # , th_vdvi = th_vdvi
    # , th_exgr = th_exgr
    # , th_a = th_a
    # , th_hue = th_hue
  )
  ##################################################
  # filtering
  ##################################################
  if(filter_return){
    rgb_indices_df <- rgb_indices_df %>% dplyr::filter(inrange_th_votes>=spectral_weight)
  }
  # return
  return(list(
    segs_sf = rgb_indices_df
    , rgb_indices_rast = all_rgb_indices_rast
  ))
}
