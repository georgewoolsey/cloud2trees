#' @title Spectral filtering of candidate slash piles
#'
#' @description Evaluates candidate segments generated by [piles_detect()]
#' against an RGB raster. It uses a voting system based on six spectral indices
#' to separate woody slash material from background vegetation or ground. This
#' function can either return a filtered dataset or the full input dataset
#' with appended spectral metrics for diagnostic purposes.
#'
#' @param sf_data An sf object of candidate polygons to be filtered.
#' @param rgb_rast A multi-band SpatRaster containing RGB imagery.
#' @param red_band_idx Integer. Index of the red band.
#' @param green_band_idx Integer. Index of the green band.
#' @param blue_band_idx Integer. Index of the blue band.
#' @param spectral_weight Integer (0 to 6). The consensus threshold
#' requiring a specific number of index thresholds to be met for a candidate
#' pile to be retained.
#' @param filter_return Logical. If TRUE (default), the function returns
#' only polygons where the "inrange_th_votes" is greater than or equal to
#' the `spectral_weight`. If FALSE, the function returns the entire input
#' dataset with columns for each calculated spectral index and the
#' "inrange_th_votes" column for post-processing and analysis.
#'
#' @return An sf object. Depending on `filter_return`, this will either be
#' a subset of the input data or the full input data with appended
#' spectral voting columns.
#'
#' @keywords internal
#'
#' @examples
#' \dontrun{
#'  ###########################################
#'  # piles_detect() test
#'  ###########################################
#'  # load a chm
#'  chm_fnm <- system.file(package = "cloud2trees", "extdata", "piles_chm.tif")
#'  my_chm <- terra::rast(chm_fnm)
#'  terra::plot(my_chm, axes = F)
#'  # piles_detect() that
#'  piles_detect_ans <- piles_detect(
#'    chm_rast = my_chm
#'    , seg_method = "dbscan"
#'    , min_ht_m = 1
#'    , max_ht_m = 4
#'    , min_area_m2 = pi*(1.5/2)^2
#'    , max_area_m2 = pi*(6/2)^2
#'    , min_convexity_ratio = 0.3
#'    , min_circularity_ratio = 0.4
#'    , smooth_segs = T
#'    , outfile = NA
#'  )
#'  # what?
#'  piles_detect_ans
#'  dplyr::glimpse(piles_detect_ans$segs_sf) # here are pile polygons
#'  # plot on orig chm
#'  terra::plot(my_chm, axes = F)
#'  piles_detect_ans$segs_sf %>%
#'    terra::vect() %>%
#'    terra::plot(border = "magenta", lwd = 2, col = NA, add = T)
#'  # plot on chm slice generated by piles_detect()
#'  terra::plot(piles_detect_ans$slice_chm_rast, axes = F, col = viridis::cividis(n=100))
#'  piles_detect_ans$segs_sf %>%
#'    terra::vect() %>%
#'    terra::plot(border = "magenta", lwd = 2, col = NA, add = T)
#'  # what if we use the `outfile` arg in piles_detect() ?
#'  my_fnm <- tempfile()
#'  piles_detect_ans2 <- piles_detect(
#'    chm_rast = my_chm
#'    , seg_method = "dbscan"
#'    , min_ht_m = 1
#'    , max_ht_m = 6.6
#'    , min_area_m2 = pi*(1.5/2)^2
#'    , max_area_m2 = pi*(8/2)^2
#'    , min_convexity_ratio = 0.11
#'    , min_circularity_ratio = 0.22
#'    , smooth_segs = T
#'    , outfile = my_fnm
#'  )
#'  piles_detect_ans2 # this is now a filename
#'  piles <- sf::st_read(piles_detect_ans2) # read it
#'  # plot on orig chm
#'  terra::plot(my_chm, axes = F)
#'  piles %>%
#'    terra::vect() %>%
#'    terra::plot(border = "magenta", lwd = 2, col = NA, add = T)
#'  ###########################################
#'  # piles_spectral_filter() test
#'  ###########################################
#'  # load rgb data
#'  rgb_fnm <- system.file(package = "cloud2trees", "extdata", "piles_rgb.tif")
#'  my_rgb <- terra::rast(rgb_fnm)
#'  my_rgb
#'  terra::plotRGB(my_rgb)
#'  piles %>%
#'    terra::vect() %>%
#'    terra::plot(border = "magenta", lwd = 2, col = NA, add = T)
#'  # piles_detect() that
#'  piles_spectral_filter_ans <- piles_spectral_filter(
#'    sf_data = piles
#'    , rgb_rast = my_rgb
#'    , red_band_idx = 1
#'    , green_band_idx = 2
#'    , blue_band_idx = 3
#'    , spectral_weight = 5
#'    , filter_return = F # don't filter the return so we can see what did not pass
#'  )
#'  piles_spectral_filter_ans
#'  # look at all these indices
#'  piles_spectral_filter_ans$rgb_indices_rast %>%
#'    terra::plot(
#'      nc = 5
#'      , col = grDevices::gray.colors(111, start = 0, end = 1)
#'      , mar = c(0.2,0.2,1.6,0.2)
#'      , axes = FALSE
#'      , legend = F
#'    )
#'  # look at the data added to the piles
#'  piles_spectral_filter_ans$segs_sf %>% dplyr::glimpse()
#'  # how many would have been filtered if
#'  # ... we set `filter_return = T`
#'  # ... with `spectral_weight = 5` ?
#'  piles_spectral_filter_ans$segs_sf %>%
#'    sf::st_drop_geometry() %>%
#'    dplyr::mutate(is_spectrally_removed = inrange_th_votes<5) %>%
#'    dplyr::count(is_spectrally_removed)
#'  # plot it
#'  terra::plotRGB(
#'    my_rgb
#'    , main = "candidate piles kept (magenta) or removed (red)"
#'    , mar = c(0.2,0.2,2,0.2)
#'  )
#'  piles_spectral_filter_ans$segs_sf %>%
#'    dplyr::filter(inrange_th_votes>=5) %>%
#'    terra::vect() %>%
#'    terra::plot(border = "magenta", lwd = 2, col = NA, add = T)
#'  piles_spectral_filter_ans$segs_sf %>%
#'    dplyr::filter(inrange_th_votes<5) %>%
#'    terra::vect() %>%
#'    terra::plot(border = "red", lwd = 2, col = NA, add = T)
#' }
#'
piles_spectral_filter <- function(
  sf_data
  , rgb_rast
  # define the band index
  , red_band_idx
  , green_band_idx
  , blue_band_idx
  # spectral weighting
  , spectral_weight = 4
  # return unfiltered or filtered
  , filter_return = T
) {
  if(!inherits(filter_return,"logical")){
    stop("Input `filter_return` should be logical: T to filter return based on the `spectral_weight` or F to return the full `sf_data`")
  }

  # ### could make these parameters
  # th_grvi <- c(-Inf,0)
  # th_rgri <- c((0.7+0.001),Inf) # increase each by 0.001 since we'll be checking lower<=x<=upper
  # th_vdvi <- c(-Inf,(0.03+0.001)) # increase each by 0.001 since we'll be checking lower<=x<=upper
  # th_exgr <- c(-Inf,0)
  # th_a <- c(-5+0.001,Inf)
  # th_hue <- list(c(0,50-0.001), c(150+0.001,Inf))

  # checks
  chk_rgb_temp <- check_rgb_raster_bands(
    rast = rgb_rast
    , red_band_idx = red_band_idx
    , green_band_idx = green_band_idx
    , blue_band_idx = blue_band_idx
  )
  if(!inherits(sf_data, "sf")){
    stop("Input `sf_data` must be an sf data frame.")
  }
  if(!all(sf::st_geometry_type(sf_data) %in% c("POLYGON", "MULTIPOLYGON"))) {
    stop("Input `sf_data` must contain polygon geometries.")
  }
  spectral_weight <- as.numeric(spectral_weight)[1]
  if(
    filter_return &&
    (
      is.na(spectral_weight) ||
      is.null(spectral_weight) ||
      is.nan(spectral_weight) ||
      !(spectral_weight %in% c(0:6))
    )
  ){
    stop("Input `spectral_weight` must be a number between 0 (no filtering based on spectral) and 6 (highest weighting of spectral data)")
  }
  # if you don't want to do it, then why do it?
  if(
    filter_return &&
    dplyr::coalesce(spectral_weight,0)==0
  ){
    return(list(
      segs_sf = sf_data
      , rgb_indices_rast = NA
    ))
  }
  # memory check and direct processing
  mem_info_temp <- terra::mem_info(rgb_rast, n = 4, print = F)
  # mem_info_temp[["fits_mem"]]
  #################################################################################
  # if the raster is already in memory, process directly to avoid tiling
  #################################################################################
  if(
    terra::inMemory(rgb_rast)
    || dplyr::coalesce(mem_info_temp[["fits_mem"]],0)==1
  ) {
    message("RGB raster is already in memory. Processing directly.")
    rgb_to_df_full_process_ans <- rgb_to_df_full_process(
        rgb_rast = rgb_rast
        , red_band_idx = red_band_idx
        , green_band_idx = green_band_idx
        , blue_band_idx = blue_band_idx
        , sf_data = sf_data
      )
    rgb_indices_df <- rgb_to_df_full_process_ans[["rgb_indices_df"]]
    all_rgb_indices_rast <- rgb_to_df_full_process_ans[["all_rgb_indices_rast"]]
  }else{
    #################################################################################
    # tiling
    #################################################################################
    message("raster is on disk (not inMemory). tile processing and `rgb_indices_rast` return will be NULL.\n  see `calculate_rgb_indices()`")
    # get_tile_size()...might work for realllllly huge rasters
    # get_tile_size(rgb_rast, memory_risk = 0.65)
    tile_size_pixels <- get_tile_size(rgb_rast, memory_risk = 0.7)[["tile_size"]]
    # tile_size_pixels

    # make grid to split up piles and so we only process where piles exist
    grid_temp <- sf::st_make_grid(
        x =
          sf_data %>%
          sf::st_transform(terra::crs(rgb_rast)) %>%
          sf::st_bbox() %>%
          sf::st_as_sfc()
        , cellsize = floor(tile_size_pixels*terra::res(rgb_rast)[1])
      ) %>%
      sf::st_as_sf() %>%
      sf::st_set_geometry("geometry") %>%
      dplyr::mutate(
        grid_id = dplyr::row_number()
        # , area_xxx = sf::st_area(geometry) %>% as.numeric()
      )

    # add row index to input sf_data for tracking
    sf_data <- sf_data %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        sf_data_row_xxx = dplyr::row_number()
      ) %>%
      # throw in hey_xxxxxxxxxx to test it works if we include non-existant columns
      dplyr::select( -dplyr::any_of(c(
        "hey_xxxxxxxxxx"
        , "is_inrange"
        , "inrange_th_grvi"
        , "inrange_th_rgri"
        , "inrange_th_vdvi"
        , "inrange_th_exgr"
        , "inrange_th_Lab_a"
        , "inrange_th_hsv_hue"
        , "rast_agg_grvi"
        , "rast_agg_rgri"
        , "rast_agg_vdvi"
        , "rast_agg_exgr"
        , "rast_agg_Lab_a"
        , "rast_agg_hsv_hue"
      )))

    # save old names for selecting
    old_names <- names(sf_data)
    # old_names

    # attach grid to pile data
    process_data_temp <-
      sf_data %>%
      sf::st_transform(terra::crs(rgb_rast)) %>%
      sf::st_point_on_surface() %>%
      dplyr::select(sf_data_row_xxx) %>%
      sf::st_intersection(grid_temp) %>%
      sf::st_drop_geometry() %>%
      dplyr::group_by(sf_data_row_xxx) %>%
      dplyr::slice_head(n=1) %>%
      dplyr::ungroup()
    # process_data_temp %>% dplyr::glimpse()

    # map over the grid tiles
    rgb_indices_df_temp <-
      unique(process_data_temp$grid_id) %>%
      # .[1:10] %>%
      purrr::map(function(grd){
        # piles index
        sf_idx <- process_data_temp %>%
          dplyr::filter(grid_id==grd) %>%
          dplyr::select(sf_data_row_xxx)
        # piles in the grid
        sf_data_polys <- sf_data %>%
          dplyr::inner_join(sf_idx, by = "sf_data_row_xxx")
        # extent of piles in the grid so we know the full pile extent is included
        sf_ext <- sf_data_polys %>%
          sf::st_bbox() %>%
          sf::st_as_sfc() %>%
          sf::st_transform(terra::crs(rgb_rast)) %>%
          sf::st_buffer(terra::res(rgb_rast)[1]*2) %>%
          terra::vect()

        # check overlap
        # Returns TRUE if any part of the vector geometry intersects the raster extent
        if(
          !any(terra::is.related(
            x = sf_ext
            , y = terra::ext(rgb_rast)
            , relation = "intersects"
          ))
        ){
          # stop("is.related error")
          return(NULL)
        }

        # crop raster
        grid_rgb_rast <- terra::crop(
          rgb_rast
          , sf_ext
          , filename = tempfile(fileext = ".tif")
        )

        # do it with the piles
        safe_rgb_to_df_full_process <- purrr::safely(rgb_to_df_full_process)
        ans_temp <- safe_rgb_to_df_full_process(
            rgb_rast = grid_rgb_rast
            , red_band_idx = red_band_idx
            , green_band_idx = green_band_idx
            , blue_band_idx = blue_band_idx
            , sf_data = sf_data_polys
          )
        if(is.null(ans_temp$error)){
          ans_temp <- ans_temp$result
          tile_rgb_indices_df <- ans_temp[["rgb_indices_df"]] %>%
            sf::st_drop_geometry()
          if(nrow(tile_rgb_indices_df)==0){return(NULL)}
          # get new data
          tile_rgb_indices_df <- tile_rgb_indices_df %>%
            dplyr::select(
              unique(c(
                "sf_data_row_xxx"
                , base::setdiff(names(tile_rgb_indices_df),old_names)
              ))
            )
          return(tile_rgb_indices_df)
        }else{
          # stop("safe_rgb_to_df_full_process error")
          return(NULL)
        }
      }) %>%
      dplyr::bind_rows()

    # rgb_indices_df_temp %>% dplyr::glimpse()
    if(nrow(rgb_indices_df_temp)==0){
      stop("could not find overlapping RGB data for input polygons")
    }

    rgb_indices_df <-
      sf_data %>%
      dplyr::left_join(rgb_indices_df_temp, by = "sf_data_row_xxx") %>%
      dplyr::mutate(inrange_th_votes = dplyr::coalesce(inrange_th_votes,0)) %>%
      dplyr::select(-c(sf_data_row_xxx))

    all_rgb_indices_rast <- NULL
  }

  ##################################################
  # filtering
  ##################################################
  if(filter_return){
    rgb_indices_df <- rgb_indices_df %>% dplyr::filter(inrange_th_votes>=spectral_weight)
  }
  # return
  return(list(
    segs_sf = rgb_indices_df
    , rgb_indices_rast = all_rgb_indices_rast
  ))
}
###############################################################################
# rgb_to_df_full_process
###############################################################################
rgb_to_df_full_process <- function(
  rgb_rast
  , red_band_idx
  , green_band_idx
  , blue_band_idx
  , sf_data
) {
  ##################################################
  # calculate_rgb_indices
  ##################################################
  all_rgb_indices_rast <- calculate_rgb_indices(
    rgb_rast = rgb_rast
    , red_band_idx = red_band_idx
    , green_band_idx = green_band_idx
    , blue_band_idx = blue_band_idx
  )
  ##################################################
  # limit to the indices we have thresholds for
  ##################################################
  some_rgb_indices_rast <-
    all_rgb_indices_rast %>%
    terra::subset(
      c(
        "grvi"
        , "rgri"
        , "vdvi"
        , "exgr"
        , "Lab_a"
        , "hsv_hue"
      )
    )
  # !!!!!!!!!!!!! convert hsv_hue to 0-360 range !!!!!!!!!!!!!
  some_rgb_indices_rast$hsv_hue <- some_rgb_indices_rast$hsv_hue*360
  ##################################################
  # extract_rast_values
  ##################################################
  rgb_indices_df <- extract_rast_values(
    sf_data = sf_data %>% dplyr::ungroup()
    , rast = some_rgb_indices_rast
    , fun_agg = "median"
  )
  ##################################################
  # rgb_indices_threshold_voting
  ##################################################
  rgb_indices_df <- rgb_indices_threshold_voting(
    rgb_indices_df=rgb_indices_df
    # , th_grvi = th_grvi
    # , th_rgri = th_rgri
    # , th_vdvi = th_vdvi
    # , th_exgr = th_exgr
    # , th_a = th_a
    # , th_hue = th_hue
  )
  return(list(
    rgb_indices_df = rgb_indices_df
    , all_rgb_indices_rast = all_rgb_indices_rast
  ))
}

###############################################################################
# extract_rast_values
###############################################################################
extract_rast_values <- function(sf_data, rast, fun_agg = "mean") {
  # checks
  if(!inherits(rast, "SpatRaster")){
    stop("Input `rast` must be a SpatRaster object.")
  }
  if(!inherits(sf_data, "sf")){
    stop("Input `sf_data` must be an sf data frame.")
  }
  if(!all(sf::st_geometry_type(sf_data) %in% c("POLYGON", "MULTIPOLYGON"))) {
    stop("Input `sf_data` must contain polygon geometries.")
  }
  # # terra list
  # valid_cpp <- c(
  #     "sum", "mean", "median", "min", "max",
  #     "modal", "weighted.mean", "none"
  #   )
  valid_cpp <- c(
      "min", "max", "count", "sum", "mean", "median",
      "mode", "majority", "minority", "variety",
      "stdev", "variance", "coefficient_of_variation",
      "weighted_mean", "weighted_sum"
    )
  if(
    !inherits(fun_agg,"character") ||
    !(fun_agg %in% valid_cpp)
  ) {
    stop(paste0("`fun_agg` must be one of: ",paste0(valid_cpp,collapse = ",")))
  }
  # crs
  sf_data <- sf_data %>% sf::st_transform(terra::crs(rast))

  # extract values for each layer within each polygon
  # extracted_values <- terra::extract(
  #   x = rast
  #   , y = sf_data
  #   , fun = fun_agg
  #   , na.rm = TRUE
  # )
  extracted_values <- exactextractr::exact_extract(
    x = rast
    , y = sf_data
    , fun = fun_agg # "median" # passing as a string uses the optimized c++ backend
    # , append_cols = "ID" # unique identifier in the output
    , progress = F
  )

  # clean data
  extracted_values <-
    extracted_values %>%
    dplyr::select( -dplyr::any_of(c(
      "hey_xxxxxxxxxx"
      , "ID"
    ))) %>%
    dplyr::rename_with(
      ~ paste0(
        "rast_agg_"
        , stringr::str_remove(.x,paste0("^",fun_agg,"."))
        , recycle0 = TRUE
      )
    )

  # Merge the extracted values back to the original sf data frame
  # The row order is preserved by terra::extract, so a direct cbind is safe
  # if no rows were dropped due to spatial mismatch.
  # For robustness, we can explicitly join by row ID if needed, but for simple cases, cbind works.
  # Assuming sf_data has a unique ID column or row order is stable:
  sf_data_with_indices <- sf_data %>% dplyr::bind_cols(extracted_values)

  return(sf_data_with_indices)
}
###############################################################################
# voting system
###############################################################################
rgb_indices_threshold_voting <- function(
  rgb_indices_df
  # define ranges to *keep* piles
  , th_grvi = c(-Inf,0)
  , th_rgri = c((0.7+0.001),Inf) # increase each by 0.001 since we'll be checking lower<=x<=upper
  , th_vdvi = c(-Inf,(0.03+0.001)) # increase each by 0.001 since we'll be checking lower<=x<=upper
  , th_exgr = c(-Inf,0)
  , th_a = c(-5+0.001,Inf)
  , th_hue = list(c(0,50-0.001), c(150+0.001,Inf))
){
  # checks
  if(!inherits(rgb_indices_df, "data.frame")){
      stop("Input `rgb_indices_df` must be an data.frame.")
  }
  # names
  agg_cols <- c("rast_agg_grvi","rast_agg_exgr","rast_agg_rgri","rast_agg_vdvi","rast_agg_Lab_a","rast_agg_hsv_hue") # "rast_agg_rgbvi",
  nm_diff <- base::setdiff(
    agg_cols
    , names(rgb_indices_df)
  )
  if(length(nm_diff)>0){
    stop(paste0("required variables missing:\n", "... ", paste(nm_diff, collapse = ", ") ))
  }
  # thresholds
  safe_validate_thresholds_fn <- purrr::safely(validate_thresholds_fn)
    # th_grvi
    chk_grvi <- safe_validate_thresholds_fn(th_grvi)
    if(is.null(chk_grvi$result)){
      stop(paste0("Input `th_grvi`: ", chk_grvi$error))
    }
    # th_rgri
    chk_rgri <- safe_validate_thresholds_fn(th_rgri)
    if(is.null(chk_rgri$result)){
      stop(paste0("Input `th_rgri`: ", chk_rgri$error))
    }
    # th_vdvi
    chk_vdvi <- safe_validate_thresholds_fn(th_vdvi)
    if(is.null(chk_vdvi$result)){
      stop(paste0("Input `th_vdvi`: ", chk_vdvi$error))
    }
    # th_exgr
    chk_exgr <- safe_validate_thresholds_fn(th_exgr)
    if(is.null(chk_exgr$result)){
      stop(paste0("Input `th_exgr`: ", chk_exgr$error))
    }
    # th_a
    chk_a <- safe_validate_thresholds_fn(th_a)
    if(is.null(chk_a$result)){
      stop(paste0("Input `th_a`: ", chk_a$error))
    }
    # th_hue
    chk_hue <- safe_validate_thresholds_fn(th_hue)
    if(is.null(chk_hue$result)){
      stop(paste0("Input `th_hue`: ", chk_hue$error))
    }

  # get rid of columns we'll create
  rgb_indices_df <- rgb_indices_df %>%
    # throw in hey_xxxxxxxxxx to test it works if we include non-existant columns
    dplyr::select( -dplyr::any_of(c(
      "hey_xxxxxxxxxx"
      , "is_inrange"
      , "inrange_th_grvi"
      , "inrange_th_rgri"
      , "inrange_th_vdvi"
      , "inrange_th_exgr"
      , "inrange_th_Lab_a"
      , "inrange_th_hsv_hue"
    )))

  # check threshold
  ret_df <- rgb_indices_df %>%
    filter_by_thresholds_fn(target_col = "rast_agg_grvi", th_list = th_grvi) %>%
    dplyr::rename(inrange_th_grvi=is_inrange) %>%
    filter_by_thresholds_fn(target_col = "rast_agg_rgri", th_list = th_rgri) %>%
    dplyr::rename(inrange_th_rgri=is_inrange) %>%
    filter_by_thresholds_fn(target_col = "rast_agg_vdvi", th_list = th_vdvi) %>%
    dplyr::rename(inrange_th_vdvi=is_inrange) %>%
    filter_by_thresholds_fn(target_col = "rast_agg_exgr", th_list = th_exgr) %>%
    dplyr::rename(inrange_th_exgr=is_inrange) %>%
    filter_by_thresholds_fn(target_col = "rast_agg_Lab_a", th_list = th_a) %>%
    dplyr::rename(inrange_th_Lab_a=is_inrange) %>%
    filter_by_thresholds_fn(target_col = "rast_agg_hsv_hue", th_list = th_hue) %>%
    dplyr::rename(inrange_th_hsv_hue=is_inrange) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(
      inrange_th_votes = sum(
        dplyr::c_across(tidyselect::starts_with("inrange_th_"))
        , na.rm = T
      ) %>%
      dplyr::coalesce(0)
    ) %>%
    dplyr::ungroup()

  #return
  return(ret_df)
}
##########################################################
#### function to validate threshold vector or list pair
##########################################################
validate_thresholds_fn <- function(th_list) {
  # input is a list or a numeric vector
  if (!is.list(th_list) && !is.numeric(th_list)) {
    stop("Validation Error: Input must be a list of pairs or a single numeric vector pair.")
  }

  # to a list to standardize the purrr::map iteration
  items_to_check <- if(is.list(th_list)){
    th_list
  }else{
    list(th_list)
  }

  # validate logic on each pair
  purrr::map(items_to_check, function(x) {
    # numeric type
    if (!is.numeric(x)) {
      stop("Validation Error: Threshold elements must be numeric.")
    }

    # length is exactly 2
    if (length(x) != 2) {
      stop(paste("Validation Error: Pair must have exactly 2 values. Found length:", length(x)))
    }

    # order (lower < upper)
    if (x[1] >= x[2]) {
      stop(paste0("Validation Error: Lower limit must be smaller than upper limit. Found: [", x[1], ", ", x[2], "]"))
    }
  })

  # 4. If all checks passed (no stop triggered), return the original input
  return(th_list)
}

##########################################################
# function to filter a data frame by a list pair and column
##########################################################
filter_by_thresholds_fn <- function(df, target_col, th_list) {
  # col exists?
  if (!(target_col %in% names(df))) {
    stop(paste0("Column '", target_col, "' not found in the data frame"))
  }

  # validate the thresholds using previous function
  valid_th <- validate_thresholds_fn(th_list)

  # thresholds to a list if a single vector was provided
  th_pairs <-
    if(is.list(valid_th)){
      valid_th
    }else{
      list(valid_th)
    }

  # use purrr::map to create a list of logical vectors (one for each pair)
  # then reduce them with '|' so any row hitting any range is kept
  df %>%
    dplyr::mutate(
      is_inrange = purrr::map(th_pairs, function(x) {
        dplyr::between(.data[[target_col]], x[1], x[2])
      }) %>%
      purrr::reduce(`|`) %>%
      as.integer()
    )
    # dplyr::filter(
    #   purrr::map(
    #     th_pairs
    #     , function(x) {
    #       dplyr::between(.data[[target_col]], x[1], x[2])
    #     }
    #   ) %>%
    #   purrr::reduce(`|`)
    # )
}
